# 调度器

调度器具备全局视图，负责将各个编译任务关联到一台编译机。

不同于[distcc](https://github.com/distcc)，全局视图可以避免由任务提交机器进行本地决策而导致负载不均衡，如压垮某台编译机的同时还有另外的机器空闲等。

## 参数

- `--acceptable_tokens`：逗号分隔的一系列`token`。调度器会校验请求中的`token`，如果不匹配于这一参数中的任何一个，则会拒绝请求。

  关于`token`的更多介绍可以参考[这篇文档](security-considerations.md)。

- `--servant_min_memory_for_accepting_new_task`：如果一台编译机的可用内存小于这儿指定的值，我们将不会向它指派更多的编译任务，默认值为`10G`。考虑到编译往往同时对CPU及内存有要求，为了避免内存耗尽导致的包括但不限于死机、触发OOM killer等，我们加上了这一逻辑做一定程度的保护。

  需要注意的是，编译过程内存是逐渐上涨的，有可能一开始内存足够，同时启动数个任务之后，内存逐渐耗尽。因此我们这儿的默认值较为保守。

## 调度算法

目前我们的调度算法较为简单，其以如下几点为目标来分配编译机：

- 优先考虑专有编译机。专有编译机负载不超过50%时任务始终分配至专有编译机。

  *负载超过50%之后需要考虑SMT导致的单核性能下降，因此此时如果有更空闲的机器会优先考虑。*

- 除非没有其他机器，尽量避免将负载分配至提交任务的机器：这允许提交任务的机器有更多的CPU资源进行预处理。

- 为避免某些机器自身已有负载过高而导致新分配的编译任务执行过慢，调度算法会考虑参与编译任务的机器负载。如果机器空闲CPU少于机器本身所能接受的最大任务数，则以较小值作为“实际能接受的最大任务数”。

  *目前，Daemon定期在心跳包内上报自己15s内的平均负载，选择15s也是为了让daemon机器负载变化对调度算法更加敏感。*

- 在剩余可选机器中尽量保证各个机器的编译负载（任务数/实际能接受的最大任务数）均衡。

在没有机器有空闲资源（包括提交方自身）时，调度器会阻塞分配请求，避免过多任务压垮编译集群。

## 缓存布隆过滤器管理

调度器会定期扫描我们的缓存并构造相应的缓存布隆过滤器，关于我们对布隆过滤器的使用可以参考[守护进程](daemon.md)中相关描述。

除此之外，为了保证布隆过滤器的时效性，在守护进程和调度器的心跳中，我们会：

- 对于接收编译任务的守护进程：上报新填充的缓存的Key来更新调度器维护的布隆过滤器。
- 对于提交编译任务的守护进程：返回其上次心跳至今，整个编译集群新填充的缓存的Key。

*部分情况下一台守护进程即提交任务又接受任务，此时上述两种行为这个守护进程和调度器之间均会发生。*

## cgroups环境

cgroups可以限制一台机器上多个cgroup的CPU配额、分配等等。这可能导致我们实际看到的CPU并不能全部使用。

这导致这个节点的**实际**处理能力难以评估。

因此，如果我们测试发现某个节点运行在cgroups下并且可能启用了CPU/内存限制，我们将不会对这个节点分发任务。

## NAT环境

这通常存在于容器环境。

部分容器平台会对容器内的IP做NAT，这种情况下容器内看到并上报的IP和外界看到的IP并不相同。

对于这种节点，我们会分别记录其“上报的IP”和调度器“观察到的IP”。如果两个IP不相同，则认为这个节点位于NAT之后。

考虑到如下几种原因，目前我们简单的屏蔽了对这些NAT之后的容器节点分发任务：

- 网络连通性问题（NAT通常需要某种打洞逻辑）。
- （我们环境下的）容器配置通常较低。
- 容器通常启用了cgroups限制资源（参见“cgroups环境”一节）。
